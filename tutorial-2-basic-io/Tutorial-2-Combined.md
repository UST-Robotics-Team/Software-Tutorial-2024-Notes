# Tutorial 2: IOs on Embed System Detailed Version

<details>
<summary>Authors</summary>

Ivan Lok(yfilok@connect.ust.hk)
Modified from:
Dicaprio Cheung, Joseph Lam, Binay Gurung, Anshuman Medhi

</details>

## Basic Structure in the `main.c`

After we have discussed some C programming technique, we are moving forward to more specific programming under STM32.

The `main.c` file for STM32 projects typically follows a structured format designed to facilitate embedded system programming. This structure is generated by STM32CubeMX and includes several key sections:

```c
int main(void) {

    /* USER CODE BEGIN 1 */
    /* USER CODE END 1 */

    /* MCU Configuration--------------------------------------------------------*/
    /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
    HAL_Init();
    /* USER CODE BEGIN Init */

    /* USER CODE END Init */

    /* Configure the system clock */
    SystemClock_Config();

    /* USER CODE BEGIN SysInit */

    /* USER CODE END SysInit */

    /* Initialize all configured peripherals */
    MX_GPIO_Init();

    //The System will call the _Init Function of all peripherals here

    /* USER CODE BEGIN 2 */
    /* USER CODE END 2 */

    /* Infinite loop */
    /* USER CODE BEGIN WHILE */
    while (1) {
        /* USER CODE END WHILE */
        /* USER CODE BEGIN 3 */
    }
    /* USER CODE END 3 */
}
```

- The most notable different is that CubeMX have pre-written a `while` loop for you, and the reason is that:

  Unlike normal program we written under course / competition context that our program only run once to solve a specific problem, You want your program run continuously control the robot.

  If you have play arduino before, the `while` loop act like the `loop()`

- Another Different the placeholder for user self-defined code. These zone created for allowing you to insert custom functionality without interfering with auto-generated code.

  STM32CubeMX generates code with predefined sections for user modifications. This ensures that user code is preserved across code regenerations, which is required when there is any change in chip configurations.

  Therefore, you should always put you code inside those designated zone:

  ```c
      /* USER CODE BEGIN Init */
      // Your Code should write here
      /* USER CODE END Init */
      // Your Code should NOT write here
  ```

## Introduction to GPIOs

General-Purpose Input/Output (GPIO) pins are essential components in embedded systems, allowing for interaction with the external environment. These digital signal pins can be configured as inputs or outputs, enabling the microcontroller to read or send discrete signals, typically represented as `HIGH (1)` or `LOW (0)`.(Sometimes we will use GPIO for analogue values but don't worry about that for now)

### Pin Naming

- Each microcontroller unit (MCU) pin can function as a GPIO.
  - These pins are organized into blocks of 16, named by letters: `GPIOA`, `GPIOB`, `GPIOC`...
    - Within each block, pins are numbered from 0 onwards, e.g., `GPIO_PIN_0`, `GPIO_PIN_1`, `GPIO_PIN_2`...
- Thus, a pin is identified by its port and number, like `GPIOE`, `GPIO_PIN_3`, often referred to as `PE3`.

To simplify code readability and maintenance, meaningful names can be assigned to pins using macros in the `main.h` file or directly within the CubeMX configuration.

1.  Configuring the Macros:

Inside `Main.h` , you can find:

```c
/* Private defines -----------------------------------------------------------*/
#define BTN1_Pin GPIO_PIN_3
#define BTN1_GPIO_Port GPIOB
/* USER CODE BEGIN Private defines */
```

⚠️Noted that your change here will be covered when you regenerate code thru CubeMX

2.  Update the Pinout Name inside CubeMX

    <figure><img src="image/GPIO_Naming.png" alt=""><figcaption></figcaption></figure>

    You can see that we name the PB3 as BTN1 inside the config, and the CubeMX will auto generate the Macros in the lefthand side

## GPIO Read and Write Function

### GPIO Input

With the correct configuration of GPIO, you would like to input and output. The library here we use is `HAL` Library

The `HAL_GPIO_ReadPin` function reads the GPIO input.

```c
/* stm32f4xx_hal_gpio.h */
GPIO_PinState HAL_GPIO_ReadPin(GPIO_TypeDef GPIOx, uint16_t GPIO_Pin);
// usage
uint8_t state = HAL_GPIO_ReadPin(BTN1_GPIO_Port, BTN1_Pin); // returns 0 or 1

//To Improve the Readability, recalling we have
	#define BTN1_Pin GPIO_PIN_3
	#define BTN1_GPIO_Port GPIOB
// Therefore you can:
#define gpio_read(gpio) HAL_GPIO_ReadPin(gpio##_GPIO_Port, gpio##_Pin)
// usage
uint8_t state = gpio_read(BTN1);
```

### GPIO Output

To reduce your workload, we have written the following output macros in your `main.h` and you can directly calling it.

- The `gpio_set(gpio)` macro sets the GPIO pin to be 1.
- The `gpio_reset(gpio)` macro resets the GPIO pin to 0.
- The `gpio_toggle(gpio)` macro toggles the GPIO pin. (i.e. changes the GPIO pin state to 1 if it was originally 0 and vice versa)

```c
/* main.h */
#define gpio_set(gpio) HAL_GPIO_WritePin(gpio##_GPIO_Port, gpio##_Pin, GPIO_PIN_SET)
#define gpio_reset(gpio) HAL_GPIO_WritePin(gpio##_GPIO_Port, gpio##_Pin, GPIO_PIN_RESET)
#define gpio_toggle(gpio) HAL_GPIO_TogglePin(gpio##_GPIO_Port, gpio##_Pin)

// usage
// Turns off the LED
gpio_set(LED1);

// Turns on the LED
gpio_reset(LED1);

// Toggles the LED
gpio_toggle(LED1);
```

### Button and LED

While we have constructed the macro to directly set a pin, by using its self-defined name, to 0/1, or to read it directly, it doesn’t always the case that the LED will on when you set to 1 or the Input return 1 when the button is pressed. You can observe the following schematics and try to understand what I mean here.

<figure><img src="image/LED_Sch.png" alt=""><figcaption></figcaption></figure>

When you set the `LED1` Pin to 1, the LED will actually off, vice versa when you set it to 0, it will on.

<figure><img src="image/BTN_Sch.png" alt=""><figcaption></figcaption></figure>

Similarly, When you press the button, the `BUT1` will return 0 to you and when the button is released, `BUT1` will return 1.

Therefore to make you code more readable, you can do such thing:

```c
/* main.h */
#define led_on(led) gpio_reset(led) // notice that reset the pin turns the led on
#define led_off(led) gpio_set(led)
#define led_toggle(led) gpio_toggle(led)

#define btn_read(btn) !gpio_read(btn)
//Or you can do:
/* main.c */
uint8_t btn1_state = !gpio_read(BTN1);
```

If one day your hardware groupmate accidentally swapped the wires of all LEDs, you can simply change the defines above. You don't need to read through your hundreds/thousands of lines of code and change every `gpio_set()` `gpio_reset()` and `gpio_read()` you wrote.

### Further Application: Pneumatic Valve

Another application you more likely to use for GPIO is Pneumatic Valve.
Pneumatic Valve is a device that controls the flow of compressed air in a pneumatic system. By providing a signal, you can control the air flow passage between various components such as cylinders or actuators. Below is the picture of a Pneumatic Valve, and you can see two air input hole on top and one air output in the buttom:
![A picture of Pneumatic Valve](./Tutorial%202%20Detailed/Festo%20Pneumatic%20valve.png)
Commonly, we will connect the output of the valve to a air cylinder, which will be expended when high pressure air flow in, and collaspe when you connect to low air pressure is provided. A clear gif is provided below for your understanding on how it works
![](./Tutorial%202%20Detailed/air_cylinder_demo.gif)
So with this this valve and air cylinder, you can able to make different application including like a clamp or something. We should be demoing some application model we have made for your understanding here.
![Photo of a clamp with valve and air cylinder]()
With the understanding on how this thing work, how you control it?
The control is really simple, the valve will connected to one inpair source(High pressure) when you give a `3V3` signal to it, and connected to another one air source when you give a `GND` signal. At the same time, the led on valve should on when you pass a `3V3` into it.

# HAL Clock

With the knowledge of GPIO, you can do a robot with instant response of input, however it is not enough.
In embedded systems, time management is crucial for tasks such as scheduling, generating PWM signals, and managing delays. The STM32 microcontroller utilizes the Hardware Abstraction Layer (HAL) to handle clock functions efficiently. This section will focus on the system clock and setting up timers for various tasks.

The system clock in STM32 is a critical component that drives the operation of the microcontroller. It provides the timing needed for executing instructions and managing peripheral operations. The HAL library offers convenient functions to interact with the system clock.

```c
uint32_t HAL_GetTick(void);
uint32_t ticks = HAL_GetTick();
// Return how many ms have pass though since the MCU start running
```

- In STM32, the MCU have introduced application time base and this time bas will increment every 1ms. Using `HAL_GetTick()` can returns the time base (in ms) since you turned on the mainboard.
- You may think of the MCU Hold a Stopwatch started when the MCU start running, and `HAL_GetTick()` are asking the MCU the reading of the Stopwatch instantly.

```c
void HAL_Delay(uint32_t Delay);
```

- This function pauses the program execution for a specified number of milliseconds.
- While straightforward, using `HAL_Delay()` can halt all operations, which is often undesirable in real-time applications. Instead, consider using non-blocking techniques to achieve delays.

### Practical Example of a non-block delay with `HAL_GetTick()`

- A LED that toggle every 200ms:

  ```c
  while (1) {
      static uint32_t last_ticks = 0;
      //Static attribute keep the value across every iterations while it will not be re-initized
      //Everything inside this if-statements gets called every 200ms
      if((HAL_GetTick() - last_ticks) >= 200){
          gpio_toggle(LED1);
          last_ticks = HAL_GetTick();
          //Store the tick of last time
      }
  }
  ```

- A LED turn on 100ms after u press the button:
  ```c
  while (1) {
      static uint32_t last_ticks = 0;
      static uint8_t BTN_Pressed = 0;
      if (!BTN_Pressed && btn_read(BTN1)){ //Only when never pressed
          BTN_Pressed = 1;
          last_ticks = HAL_GetTick();
      }
      if(BTN_Pressed && (HAL_GetTick() - last_ticks) >= 100){
          led_on(LED1);
      }
  }
  ```

## Action that constantly repeat

### Program Structure:

```c
int main(void)
{
    // Initialize Everything Here, this is like setup() in Arduino
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();     //Initialize most GPIOs on board
    MX_DMA_Init();      //Initialize DMA

    while (1) {
        static uint32_t last_ticks = 0;	//Static attribute keeps its stored value through every iteration
        //Everything inside this if-statements gets called every 100ms
        if((HAL_GetTick() - last_ticks) >= 100){
            // do something every 100 ms
            last_ticks = HAL_GetTick();
            //Store the tick of last time
        }

        static uint32_t last_ticks2 = 0;	//This variable keeps its stored value through every iteration
        //Everything inside this if-statements gets called every 60ms
        if((HAL_GetTick() - last_ticks2) >= 60){
            // do another thing every 60 ms
            last_ticks2 = HAL_GetTick();
        }
    }
}
```

- In the example above, we do something every 100 ms and another thing every 60 ms. Since they are only an if-statement, there won't be any while loops/ for loops that prevent the other tasks from doing their tasks.
- This structure is easy and keep your MCU active all the time to do whatever you want it to do.

### Why Delay doesn’t work?

You may think you can write it as delay like this:

```c
while(1){
    //do something (task1)
    HAL_Delay(100);
    //do another thing (task2)
    HAL_Delay(60);
}
```

This doesn't work as task1 need to wait for 100+60 ms before it can execute again and task2 also need to wait for 60+100 ms before it can execute again. This is not what we want.

You might say you can carefully design the delay time such that it delays accurately:

T1, T2, delay 60, T2, delay 40, T1, delay 20, T2, delay 60, T2, delay 20, T1, delay 40, T2, delay 60

However, you will have to write many different tasks(>10) for the mainboard to do in many different intervals. it is nearly impossible for you to design a delay pattern for that many tasks accurately. It is also difficult to add, remove, or modify the interval if you write using delay.

> Therefore you shouldn’t use `HAL_Delay()` in basically most of the time

<details><summary>Side Note:  Actually `HAL_Delay()` are just using `HAL_GetTick()`</summary>
     
```c
__weak void HAL_Delay(uint32_t Delay)
{
uint32_t tickstart = HAL_GetTick();
uint32_t wait = Delay;

/_ Add a freq to guarantee minimum wait _/
if (wait < HAL_MAX_DELAY)
{
wait += (uint32_t)(uwTickFreq);
}

while((HAL_GetTick() - tickstart) < wait)
{
}
}

````
 </details>

## Classwork 1: GPIO and HAL
To hold our code integrity and also enable you guys to further apply this project in the later RDC Phase, we have already set up a separate file `tutorial 2.c`. You should write your code there in the respective function and call the function in the `main.c`
Remember to add the function prototype before you call it.
```c
/* main.c */
/* USER CODE BEGIN PFP */
void gpio_classwork(void);
/* USER CODE END PFP */
````

- When `BTN1` is held, `LED1` should be on. **(@1)**
- When `BTN2` is held, `LED1` should be flashing (toggle in 50ms).**(@1)**
- When both `BTN1` and `BTN2` are held, the following sequence is conducted:**(@2)**
  - `LED1` on while `LED2` are flashing (toggle in 50ms), for one second.
  - `LED1` and `LED3` are flashing while `LED2` are on, for one second.
  - Repeat from step 1.
- Keyword: Finite State Machine

# TFT

## Printing Something

> Back in the days we learn programming, the integrated development environment (IDE) most likely provide you a console to output and you often use it for debugging and keep track with your programming progress.
> And in different programming language, you can print / show your variable value using print function.

In C,

```c
int c = 25;
printf("The value of c-squared is : %d",c*c);
//Output will come as "The value of c-squared is : 625"
```

In Python,

```py
c = 25
print("The value of c-squared is: ",c*c) # c**2
#Output will come as "The value of c-squared is : 625"
```

In Java,

```java
int c = 25;
System.out.println("The value of c-squared is " + c*c);
//Output will come as "The value of c-squared is : 625"
```

However in the Embed C Environment, you cannot direct access to the console of the C runtime and connect it to debugger is not always possible and is troublesome indeed. (Experience tell that debug the debugger is a painful experience)

Therefore, we would like to make use of TFT (aka a small LCD monitor), to provide ourselves places to print out our variable and make our life easiler.

## Using the TFT

### `tft_init`

```c
void tft_init(TFT_ORIENTATION orientation, uint16_t bg_color, uint16_t text_color, uint16_t text_color_sp, uint16_t highlight_color);

//Usage
/* main.c*/
/* USER CODE BEGIN 2 */
tft_init(PIN_ON_TOP, BLACK, WHITE, YELLOW, DARK_GREEN);
/* USER CODE END 2 */
```

<details>
    <summary>Parameter Detail</summary>

- orientation - _**Orientation of the monitor**_
- bg*color - ***Background color**\_
- text*color - ***Text color**\_
- text*color_sp - ***Special Text color**\_ - `[]`
- highlight*color - ***Highlight color**\_ - `{}`

The parameters have already been defined for you in `lcd.h` header-file. It is defined as follows:

### \* **Orientation**

```c
typedef enum {
    PIN_ON_TOP,
    PIN_ON_LEFT,
    PIN_ON_BOTTOM,
    PIN_ON_RIGHT
} TFT_ORIENTATION;
```

### \* **Colors**

You may choose one of the following colours according to your own desire for the **TFT**. Of course! You may also define new color yourself. The following are RGB565 format

```c
#define WHITE           (RGB888TO565(0xFFFFFF))
#define BLACK           (RGB888TO565(0x000000))
#define DARK_GREY       (RGB888TO565(0x555555))
#define GREY            (RGB888TO565(0xAAAAAA))
#define RED             (RGB888TO565(0xFF0000))
#define DARK_RED        (RGB888TO565(0x800000))
#define ORANGE          (RGB888TO565(0xFF9900))
#define YELLOW          (RGB888TO565(0xFFFF00))
#define GREEN           (RGB888TO565(0x00FF00))
#define DARK_GREEN      (RGB888TO565(0x00CC00))
#define BLUE            (RGB888TO565(0x0000FF))
#define BLUE2           (RGB888TO565(0x202060))
#define SKY_BLUE        (RGB888TO565(0x11CFFF))
#define CYAN            (RGB888TO565(0x8888FF))
#define PURPLE          (RGB888TO565(0x00AAAA))
#define PINK            (RGB888TO565(0xC71585))
#define GRAYSCALE(S)    (2113*S)
```

### **Example:**

```c
/*
 * Initialisation Example
 *
 * Orientation : Pin_on_top
 * Background color : black
 * Text color : white
 * Special Text color : red
 * Highlight color : dark green
 */

tft_init(PIN_ON_TOP, BLACK, WHITE, RED, DARK_GREEN);
```

</details>

### **Print String**

```c
void tft_prints(uint8_t x, uint8_t y, const char* fmt, ...);
```

- **x**: nth horizontal column ranging from 0 to 15 (16 columns)
- **y**: nth vertical row, ranging from 0 to 9 (10 rows)
- **fmt**: string with format templates (same as C's printf)
- **...** : variable to replace the placeholder in the string (same as C's printf)

#### Example

```c
int a = 10;
tft_prints(0, 0, "The value of a is %d", a);
// The value of a is 10
```

## Classwork 2: TFT

- Print the time elapsed with the format of `mm:ss:sssZ` where `sssZ` means millisecond. e.g. `00:23:109` **(@2)**
- Print a 50px \* 50px square directly under the elapsed time where its color changes when 1 second passed.**(@2)**
  > Remember to add the function prototype before you call it.
  >
  > ```c
  > /* main.c */
  > /* USER CODE BEGIN PFP */
  > void tft_classwork(void);
  > /* USER CODE END PFP */
  > ```
  >
  > Hints: Making use of mod and integer division.

## More Application

<details>
<summary>More Application</summary>

### **Print Pixel**

```c
void tft_print_pixel(uint16_t color, uint32_t x, uint32_t y);
```

- **color** : colour of your pixel (Use the #define colours)
- **x** : n-th horizontal pixel, ranging from 0 to 127
- **y** : n-th vertical pixel , ranging from 0 to 159

### **Update**

```c
uint8_t tft_update(uint32_t period);
uint8_t tft_update2(uint32_t period);

// update the screen to print text and colors
```

- **period** : period of update in ms

### **Miscellaneous**

```c
void drawLine(int16_t x0, int16_t y0, int16_t x1, int16_t y1, uint16_t color);

void drawCircle(int16_t x0, int16_t y0, int16_t r, uint16_t color);

void drawTriangle(int16_t x0, int16_t y0, int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color)
```

### **Example of using TFT**

```c
while(1){
    /*This is referring to your main while(1) loop,
      Do not create another while(1)*/
    if(tft_update(50) == 0){
        tft_prints(0, 0, "Hello World"); // normal
        tft_prints(0, 1, "[Hello World]");  // This is a special text with differnt color
        tft_prints(0, 2, "{Hello World}");  // This is a higlighted text
        tft_prints(0, 3, "|Hello World|");  // This is a underlined text
    }
}
```

</details>

## Basic STM32 Configuration

Thoughout the jounery of your RDC, your are not likely to configurate all the pinout and function module from scratch, as there are many technical consideration behind the configuration. Therefore, we have already make you a mostly done configuration file, which is the "SW Tutorial", we have basically include CAN, LED, TFT and PWM those most commonly used pinout and function.
However, you may still need to make use of some GPIO pin and we cannot predict what and where you are plug in to the board, therefore we are still introducing you some basic skill to setup a GPIO Pins.

### Project Structure

In the project, commonly you will see a folder structure:
![Project structure](./Tutorial%202%20Detailed/project%20structure.png)
Several thing we want to high light:

- The `includes` is stored those **Fundemental** library and those are not something you suppose to change. The user-written header should be stored in `/Core/Inc`.
- In the `sw-tutorial.ioc`, if u click it, you will enter the GUI of CubeMX, which is a GUI tools provided to allow user to config the different pinout
- You should noted that changing the config file inself will not able to effect the operation instantly, instead, you need to `Generate Code` in CubeMX and make the configuration effective

### Configuration & Pinnot Page

When you click the `.ioc`, you should be enter a such a interface
![](./Tutorial%202%20Detailed/Pinout%20&%20Config.png)

- The left most panel is the Module Panel, in which you are select all the possible sub-system which is available on the current chip you selected
- The second left one is the configuration panel, in which you can access and setup detail configuration there
- The right main panel is the pinout panel, in which you can choose the purpose of every pinout

### How to configurate a GPIO Pin

First, we need to find the correct pin we want to connect, like may be `PA3`, you need to pick the pin according to hardware schmatic:

Finally, it is good to go and you can just call the LED but the macro we have wrote previously.

### Extended Reading: GPIO Input Mode

- As we have mentioned, our GPIO only receive discrete 0/1 signal, so it is trivial enough when we have a GND / 3.3V(out TTL is set to be 3.3V) given to the port, but what if it is not connecting to anything?
- When it is not connected to anything, it is the case we say it is float, and it will lead to a unpredictable readings due to noise.
- Following Schematics provide you example of connection to nothing:

    <figure><img src="image/Button_Sch.png" alt=""><figcaption></figcaption></figure>
    
    - When the button is pressed, the `BUT1` pin connected to `GND` , which refer to 0.
    - How about when the button is released?
        - Noise will cause you to read a mostly random value
    - Therefore we want to have some mechanism to make it to be a `1` or `3.3V` when the button is released, in the other words, and that is `PULL-UP`  in this case.

- The pull-up or pull-down gives a "**weak**" connection from the pin to either a high or low voltage. It gives a defined value to a floating pin while being weak enough to be easily overridden by any external signal.

#### Pull Up and Pull Down

<figure><img src="image/Pull_Up.png" alt=""><figcaption></figcaption></figure>

<figure><img src="image/Pull_Down.png" alt=""><figcaption></figcaption></figure>

When you choose `Pull Up` or `Pull Down` in the configuration, the MCU will connect the input to the `Vcc` / `GND` by itself and reduced the need for additional hardware components on the PCB.

⭐Other than `Pull Up` or `Pull Down` , you may also choose the `No Pull` for Input Mode if your PCB have already drawn to connect both 3V3 and GND by default.

### Extended Reading: GPIO Output Mode

- Similar to Input, we have two mode of output in GPIO, namely **Push-pull** and **Open-drain**
  - **Push-pull(PP)** uses the 2 switches to connect the pin to either high voltage or low voltage, it pushes or pulls the voltage to the level assigned
  - **Open-drain(OD)** is similar but does not use the upper switch, thus it outputs a low voltage or completely disconnects the pin
- Inside the MCU lives a pair of switches, ie.`transistors`:
    <figure><img src="image/GPIO_Output_Mode.png" alt=""><figcaption></figcaption></figure>

### Side Tracker: GPIO Configuration

Below we extract one GPIO `_Init` segment for you to see what is taking place during GPIO INIT, but you does not required to understand what is happening behind

```c
void MX_GPIO_Init(void)
{

  GPIO_InitTypeDef GPIO_InitStruct = {0};

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOB_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, TFT_BL_Pin|CAM_WEN_Pin|CAM_RCLK_Pin|LED4_Pin
                          |LED3_Pin|LED2_Pin|LED1_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin : PtPin */
  GPIO_InitStruct.Pin = BTN1_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_PULLUP;
  HAL_GPIO_Init(BTN1_GPIO_Port, &GPIO_InitStruct);

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
}
```
